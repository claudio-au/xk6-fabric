/*-
 * ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 * Autonomic Proprietary 1.0
 * ——————————————————————————————————————————————————————————————————————————————
 * Copyright (C) 2020 Autonomic, LLC - All rights reserved
 * ——————————————————————————————————————————————————————————————————————————————
 * Proprietary and confidential.
 *
 * NOTICE:  All information contained herein is, and remains the property of
 * Autonomic, LLC and its suppliers, if any.  The intellectual and technical
 * concepts contained herein are proprietary to Autonomic, LLC and its suppliers
 * and may be covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this information
 * or reproduction of this material is strictly forbidden unless prior written
 * permission is obtained from Autonomic, LLC.
 *
 * Unauthorized copy of this file, via any medium is strictly prohibited.
 * ______________________________________________________________________________
 */
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: autonomic/ext/feed/consumer/consumer.proto

package consumer

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetStartReferenceRequest_StartReferenceType int32

const (
	GetStartReferenceRequest_UNKNOWN_START_REFERENCE_TYPE GetStartReferenceRequest_StartReferenceType = 0
	GetStartReferenceRequest_EARLIEST                     GetStartReferenceRequest_StartReferenceType = 1
	GetStartReferenceRequest_LATEST                       GetStartReferenceRequest_StartReferenceType = 2
	GetStartReferenceRequest_AFTER_REFERENCE              GetStartReferenceRequest_StartReferenceType = 3
	GetStartReferenceRequest_AT_TIMESTAMP                 GetStartReferenceRequest_StartReferenceType = 4
)

var GetStartReferenceRequest_StartReferenceType_name = map[int32]string{
	0: "UNKNOWN_START_REFERENCE_TYPE",
	1: "EARLIEST",
	2: "LATEST",
	3: "AFTER_REFERENCE",
	4: "AT_TIMESTAMP",
}

var GetStartReferenceRequest_StartReferenceType_value = map[string]int32{
	"UNKNOWN_START_REFERENCE_TYPE": 0,
	"EARLIEST":                     1,
	"LATEST":                       2,
	"AFTER_REFERENCE":              3,
	"AT_TIMESTAMP":                 4,
}

func (x GetStartReferenceRequest_StartReferenceType) String() string {
	return proto.EnumName(GetStartReferenceRequest_StartReferenceType_name, int32(x))
}

func (GetStartReferenceRequest_StartReferenceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{3, 0}
}

type GetFlowRequest struct {
	Flow                 string   `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFlowRequest) Reset()         { *m = GetFlowRequest{} }
func (m *GetFlowRequest) String() string { return proto.CompactTextString(m) }
func (*GetFlowRequest) ProtoMessage()    {}
func (*GetFlowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{0}
}

func (m *GetFlowRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFlowRequest.Unmarshal(m, b)
}
func (m *GetFlowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFlowRequest.Marshal(b, m, deterministic)
}
func (m *GetFlowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFlowRequest.Merge(m, src)
}
func (m *GetFlowRequest) XXX_Size() int {
	return xxx_messageInfo_GetFlowRequest.Size(m)
}
func (m *GetFlowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFlowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFlowRequest proto.InternalMessageInfo

func (m *GetFlowRequest) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

type ShardInfo struct {
	Id                   []byte               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Messages             uint64               `protobuf:"varint,2,opt,name=messages,proto3" json:"messages,omitempty"`
	Bytes                uint64               `protobuf:"varint,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
	LastReceived         *timestamp.Timestamp `protobuf:"bytes,4,opt,name=last_received,json=lastReceived,proto3" json:"last_received,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShardInfo) Reset()         { *m = ShardInfo{} }
func (m *ShardInfo) String() string { return proto.CompactTextString(m) }
func (*ShardInfo) ProtoMessage()    {}
func (*ShardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{1}
}

func (m *ShardInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShardInfo.Unmarshal(m, b)
}
func (m *ShardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShardInfo.Marshal(b, m, deterministic)
}
func (m *ShardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardInfo.Merge(m, src)
}
func (m *ShardInfo) XXX_Size() int {
	return xxx_messageInfo_ShardInfo.Size(m)
}
func (m *ShardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardInfo proto.InternalMessageInfo

func (m *ShardInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ShardInfo) GetMessages() uint64 {
	if m != nil {
		return m.Messages
	}
	return 0
}

func (m *ShardInfo) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *ShardInfo) GetLastReceived() *timestamp.Timestamp {
	if m != nil {
		return m.LastReceived
	}
	return nil
}

type GetFlowResponse struct {
	Shards               []*ShardInfo         `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	TotalMessages        uint64               `protobuf:"varint,2,opt,name=total_messages,json=totalMessages,proto3" json:"total_messages,omitempty"`
	TotalBytes           uint64               `protobuf:"varint,3,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	LastReceived         *timestamp.Timestamp `protobuf:"bytes,4,opt,name=last_received,json=lastReceived,proto3" json:"last_received,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetFlowResponse) Reset()         { *m = GetFlowResponse{} }
func (m *GetFlowResponse) String() string { return proto.CompactTextString(m) }
func (*GetFlowResponse) ProtoMessage()    {}
func (*GetFlowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{2}
}

func (m *GetFlowResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFlowResponse.Unmarshal(m, b)
}
func (m *GetFlowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFlowResponse.Marshal(b, m, deterministic)
}
func (m *GetFlowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFlowResponse.Merge(m, src)
}
func (m *GetFlowResponse) XXX_Size() int {
	return xxx_messageInfo_GetFlowResponse.Size(m)
}
func (m *GetFlowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFlowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFlowResponse proto.InternalMessageInfo

func (m *GetFlowResponse) GetShards() []*ShardInfo {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *GetFlowResponse) GetTotalMessages() uint64 {
	if m != nil {
		return m.TotalMessages
	}
	return 0
}

func (m *GetFlowResponse) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *GetFlowResponse) GetLastReceived() *timestamp.Timestamp {
	if m != nil {
		return m.LastReceived
	}
	return nil
}

type GetStartReferenceRequest struct {
	Flow      string                                      `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	Shard     []byte                                      `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	StartType GetStartReferenceRequest_StartReferenceType `protobuf:"varint,3,opt,name=start_type,json=startType,proto3,enum=autonomic.ext.feed.consumer.GetStartReferenceRequest_StartReferenceType" json:"start_type,omitempty"`
	// Types that are valid to be assigned to StartParameter:
	//	*GetStartReferenceRequest_Reference
	//	*GetStartReferenceRequest_Timestamp
	StartParameter       isGetStartReferenceRequest_StartParameter `protobuf_oneof:"start_parameter"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *GetStartReferenceRequest) Reset()         { *m = GetStartReferenceRequest{} }
func (m *GetStartReferenceRequest) String() string { return proto.CompactTextString(m) }
func (*GetStartReferenceRequest) ProtoMessage()    {}
func (*GetStartReferenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{3}
}

func (m *GetStartReferenceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetStartReferenceRequest.Unmarshal(m, b)
}
func (m *GetStartReferenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetStartReferenceRequest.Marshal(b, m, deterministic)
}
func (m *GetStartReferenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStartReferenceRequest.Merge(m, src)
}
func (m *GetStartReferenceRequest) XXX_Size() int {
	return xxx_messageInfo_GetStartReferenceRequest.Size(m)
}
func (m *GetStartReferenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStartReferenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStartReferenceRequest proto.InternalMessageInfo

func (m *GetStartReferenceRequest) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *GetStartReferenceRequest) GetShard() []byte {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *GetStartReferenceRequest) GetStartType() GetStartReferenceRequest_StartReferenceType {
	if m != nil {
		return m.StartType
	}
	return GetStartReferenceRequest_UNKNOWN_START_REFERENCE_TYPE
}

type isGetStartReferenceRequest_StartParameter interface {
	isGetStartReferenceRequest_StartParameter()
}

type GetStartReferenceRequest_Reference struct {
	Reference []byte `protobuf:"bytes,4,opt,name=reference,proto3,oneof"`
}

type GetStartReferenceRequest_Timestamp struct {
	Timestamp *timestamp.Timestamp `protobuf:"bytes,5,opt,name=timestamp,proto3,oneof"`
}

func (*GetStartReferenceRequest_Reference) isGetStartReferenceRequest_StartParameter() {}

func (*GetStartReferenceRequest_Timestamp) isGetStartReferenceRequest_StartParameter() {}

func (m *GetStartReferenceRequest) GetStartParameter() isGetStartReferenceRequest_StartParameter {
	if m != nil {
		return m.StartParameter
	}
	return nil
}

func (m *GetStartReferenceRequest) GetReference() []byte {
	if x, ok := m.GetStartParameter().(*GetStartReferenceRequest_Reference); ok {
		return x.Reference
	}
	return nil
}

func (m *GetStartReferenceRequest) GetTimestamp() *timestamp.Timestamp {
	if x, ok := m.GetStartParameter().(*GetStartReferenceRequest_Timestamp); ok {
		return x.Timestamp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetStartReferenceRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetStartReferenceRequest_Reference)(nil),
		(*GetStartReferenceRequest_Timestamp)(nil),
	}
}

type GetStartReferenceResponse struct {
	Reference            []byte   `protobuf:"bytes,1,opt,name=reference,proto3" json:"reference,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStartReferenceResponse) Reset()         { *m = GetStartReferenceResponse{} }
func (m *GetStartReferenceResponse) String() string { return proto.CompactTextString(m) }
func (*GetStartReferenceResponse) ProtoMessage()    {}
func (*GetStartReferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{4}
}

func (m *GetStartReferenceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetStartReferenceResponse.Unmarshal(m, b)
}
func (m *GetStartReferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetStartReferenceResponse.Marshal(b, m, deterministic)
}
func (m *GetStartReferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStartReferenceResponse.Merge(m, src)
}
func (m *GetStartReferenceResponse) XXX_Size() int {
	return xxx_messageInfo_GetStartReferenceResponse.Size(m)
}
func (m *GetStartReferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStartReferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStartReferenceResponse proto.InternalMessageInfo

func (m *GetStartReferenceResponse) GetReference() []byte {
	if m != nil {
		return m.Reference
	}
	return nil
}

type GetEventsRequest struct {
	// Name of the flow from which we want events
	Flow string `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	// Identifier of the shard from which we want events
	Shard []byte `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	// Reference at which we want to begin receiving events
	Reference []byte `protobuf:"bytes,3,opt,name=reference,proto3" json:"reference,omitempty"`
	// Timeout in milliseconds to wait for events; a value of 0 disables timeout
	Timeout uint32 `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// The maximum number of events to return; a value of 0 means no maximum
	CountLimit uint32 `protobuf:"varint,5,opt,name=count_limit,json=countLimit,proto3" json:"count_limit,omitempty"`
	// The maximum number of bytes to return; a value of 0 means no maximum
	SizeLimit uint32 `protobuf:"varint,6,opt,name=size_limit,json=sizeLimit,proto3" json:"size_limit,omitempty"`
	// Dedup contiguous duplicate events
	DedupContiguousIdenticalEvents bool     `protobuf:"varint,7,opt,name=dedup_contiguous_identical_events,json=dedupContiguousIdenticalEvents,proto3" json:"dedup_contiguous_identical_events,omitempty"`
	XXX_NoUnkeyedLiteral           struct{} `json:"-"`
	XXX_unrecognized               []byte   `json:"-"`
	XXX_sizecache                  int32    `json:"-"`
}

func (m *GetEventsRequest) Reset()         { *m = GetEventsRequest{} }
func (m *GetEventsRequest) String() string { return proto.CompactTextString(m) }
func (*GetEventsRequest) ProtoMessage()    {}
func (*GetEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{5}
}

func (m *GetEventsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetEventsRequest.Unmarshal(m, b)
}
func (m *GetEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetEventsRequest.Marshal(b, m, deterministic)
}
func (m *GetEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsRequest.Merge(m, src)
}
func (m *GetEventsRequest) XXX_Size() int {
	return xxx_messageInfo_GetEventsRequest.Size(m)
}
func (m *GetEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsRequest proto.InternalMessageInfo

func (m *GetEventsRequest) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *GetEventsRequest) GetShard() []byte {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *GetEventsRequest) GetReference() []byte {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *GetEventsRequest) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *GetEventsRequest) GetCountLimit() uint32 {
	if m != nil {
		return m.CountLimit
	}
	return 0
}

func (m *GetEventsRequest) GetSizeLimit() uint32 {
	if m != nil {
		return m.SizeLimit
	}
	return 0
}

func (m *GetEventsRequest) GetDedupContiguousIdenticalEvents() bool {
	if m != nil {
		return m.DedupContiguousIdenticalEvents
	}
	return false
}

type GetEventsResponse struct {
	Events               []*FeedEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetEventsResponse) Reset()         { *m = GetEventsResponse{} }
func (m *GetEventsResponse) String() string { return proto.CompactTextString(m) }
func (*GetEventsResponse) ProtoMessage()    {}
func (*GetEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{6}
}

func (m *GetEventsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetEventsResponse.Unmarshal(m, b)
}
func (m *GetEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetEventsResponse.Marshal(b, m, deterministic)
}
func (m *GetEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsResponse.Merge(m, src)
}
func (m *GetEventsResponse) XXX_Size() int {
	return xxx_messageInfo_GetEventsResponse.Size(m)
}
func (m *GetEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsResponse proto.InternalMessageInfo

func (m *GetEventsResponse) GetEvents() []*FeedEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type FeedEvent struct {
	Reference []byte               `protobuf:"bytes,1,opt,name=reference,proto3" json:"reference,omitempty"`
	Timestamp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ShardKey  string               `protobuf:"bytes,3,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
	TypedData *any.Any             `protobuf:"bytes,5,opt,name=typed_data,json=typedData,proto3" json:"typed_data,omitempty"`
	// Additional information about the asset
	AssetInfo *AssetInfo `protobuf:"bytes,7,opt,name=asset_info,json=assetInfo,proto3" json:"asset_info,omitempty"`
	// aux storage for dynamic tracing
	TraceSpan            map[string]string `protobuf:"bytes,8,rep,name=trace_span,json=traceSpan,proto3" json:"trace_span,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FeedEvent) Reset()         { *m = FeedEvent{} }
func (m *FeedEvent) String() string { return proto.CompactTextString(m) }
func (*FeedEvent) ProtoMessage()    {}
func (*FeedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{7}
}

func (m *FeedEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeedEvent.Unmarshal(m, b)
}
func (m *FeedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeedEvent.Marshal(b, m, deterministic)
}
func (m *FeedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedEvent.Merge(m, src)
}
func (m *FeedEvent) XXX_Size() int {
	return xxx_messageInfo_FeedEvent.Size(m)
}
func (m *FeedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FeedEvent proto.InternalMessageInfo

func (m *FeedEvent) GetReference() []byte {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *FeedEvent) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *FeedEvent) GetShardKey() string {
	if m != nil {
		return m.ShardKey
	}
	return ""
}

func (m *FeedEvent) GetTypedData() *any.Any {
	if m != nil {
		return m.TypedData
	}
	return nil
}

func (m *FeedEvent) GetAssetInfo() *AssetInfo {
	if m != nil {
		return m.AssetInfo
	}
	return nil
}

func (m *FeedEvent) GetTraceSpan() map[string]string {
	if m != nil {
		return m.TraceSpan
	}
	return nil
}

type AssetInfo struct {
	VehicleAssetInfo     *VehicleAssetInfo `protobuf:"bytes,1,opt,name=vehicle_asset_info,json=vehicleAssetInfo,proto3" json:"vehicle_asset_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AssetInfo) Reset()         { *m = AssetInfo{} }
func (m *AssetInfo) String() string { return proto.CompactTextString(m) }
func (*AssetInfo) ProtoMessage()    {}
func (*AssetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{8}
}

func (m *AssetInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AssetInfo.Unmarshal(m, b)
}
func (m *AssetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AssetInfo.Marshal(b, m, deterministic)
}
func (m *AssetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetInfo.Merge(m, src)
}
func (m *AssetInfo) XXX_Size() int {
	return xxx_messageInfo_AssetInfo.Size(m)
}
func (m *AssetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AssetInfo proto.InternalMessageInfo

func (m *AssetInfo) GetVehicleAssetInfo() *VehicleAssetInfo {
	if m != nil {
		return m.VehicleAssetInfo
	}
	return nil
}

type VehicleAssetInfo struct {
	Vin                  string   `protobuf:"bytes,1,opt,name=vin,proto3" json:"vin,omitempty"`
	LastKnownEsn         string   `protobuf:"bytes,2,opt,name=last_known_esn,json=lastKnownEsn,proto3" json:"last_known_esn,omitempty"`
	LastKnownIccid       string   `protobuf:"bytes,3,opt,name=last_known_iccid,json=lastKnownIccid,proto3" json:"last_known_iccid,omitempty"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Serial               string   `protobuf:"bytes,5,opt,name=serial,proto3" json:"serial,omitempty"`
	RegionCode           string   `protobuf:"bytes,7,opt,name=region_code,json=regionCode,proto3" json:"region_code,omitempty"`
	ProtocolVersion      string   `protobuf:"bytes,8,opt,name=region_code,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VehicleAssetInfo) Reset()         { *m = VehicleAssetInfo{} }
func (m *VehicleAssetInfo) String() string { return proto.CompactTextString(m) }
func (*VehicleAssetInfo) ProtoMessage()    {}
func (*VehicleAssetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{9}
}

func (m *VehicleAssetInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VehicleAssetInfo.Unmarshal(m, b)
}
func (m *VehicleAssetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VehicleAssetInfo.Marshal(b, m, deterministic)
}
func (m *VehicleAssetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VehicleAssetInfo.Merge(m, src)
}
func (m *VehicleAssetInfo) XXX_Size() int {
	return xxx_messageInfo_VehicleAssetInfo.Size(m)
}
func (m *VehicleAssetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VehicleAssetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VehicleAssetInfo proto.InternalMessageInfo

func (m *VehicleAssetInfo) GetVin() string {
	if m != nil {
		return m.Vin
	}
	return ""
}

func (m *VehicleAssetInfo) GetLastKnownEsn() string {
	if m != nil {
		return m.LastKnownEsn
	}
	return ""
}

func (m *VehicleAssetInfo) GetLastKnownIccid() string {
	if m != nil {
		return m.LastKnownIccid
	}
	return ""
}

func (m *VehicleAssetInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VehicleAssetInfo) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *VehicleAssetInfo) GetRegionCode() string {
	if m != nil {
		return m.RegionCode
	}
	return ""
}

func (m *VehicleAssetInfo) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

type FeedConsumerPingRequest struct {
	ClientTime           *timestamp.Timestamp `protobuf:"bytes,1,opt,name=client_time,json=clientTime,proto3" json:"client_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FeedConsumerPingRequest) Reset()         { *m = FeedConsumerPingRequest{} }
func (m *FeedConsumerPingRequest) String() string { return proto.CompactTextString(m) }
func (*FeedConsumerPingRequest) ProtoMessage()    {}
func (*FeedConsumerPingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{10}
}

func (m *FeedConsumerPingRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeedConsumerPingRequest.Unmarshal(m, b)
}
func (m *FeedConsumerPingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeedConsumerPingRequest.Marshal(b, m, deterministic)
}
func (m *FeedConsumerPingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedConsumerPingRequest.Merge(m, src)
}
func (m *FeedConsumerPingRequest) XXX_Size() int {
	return xxx_messageInfo_FeedConsumerPingRequest.Size(m)
}
func (m *FeedConsumerPingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedConsumerPingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FeedConsumerPingRequest proto.InternalMessageInfo

func (m *FeedConsumerPingRequest) GetClientTime() *timestamp.Timestamp {
	if m != nil {
		return m.ClientTime
	}
	return nil
}

type FeedConsumerPingResponse struct {
	ClientTime           *timestamp.Timestamp `protobuf:"bytes,1,opt,name=client_time,json=clientTime,proto3" json:"client_time,omitempty"`
	ServerTime           *timestamp.Timestamp `protobuf:"bytes,2,opt,name=server_time,json=serverTime,proto3" json:"server_time,omitempty"`
	Greeting             string               `protobuf:"bytes,3,opt,name=greeting,proto3" json:"greeting,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FeedConsumerPingResponse) Reset()         { *m = FeedConsumerPingResponse{} }
func (m *FeedConsumerPingResponse) String() string { return proto.CompactTextString(m) }
func (*FeedConsumerPingResponse) ProtoMessage()    {}
func (*FeedConsumerPingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bac3b738a7c7306, []int{11}
}

func (m *FeedConsumerPingResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeedConsumerPingResponse.Unmarshal(m, b)
}
func (m *FeedConsumerPingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeedConsumerPingResponse.Marshal(b, m, deterministic)
}
func (m *FeedConsumerPingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedConsumerPingResponse.Merge(m, src)
}
func (m *FeedConsumerPingResponse) XXX_Size() int {
	return xxx_messageInfo_FeedConsumerPingResponse.Size(m)
}
func (m *FeedConsumerPingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedConsumerPingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FeedConsumerPingResponse proto.InternalMessageInfo

func (m *FeedConsumerPingResponse) GetClientTime() *timestamp.Timestamp {
	if m != nil {
		return m.ClientTime
	}
	return nil
}

func (m *FeedConsumerPingResponse) GetServerTime() *timestamp.Timestamp {
	if m != nil {
		return m.ServerTime
	}
	return nil
}

func (m *FeedConsumerPingResponse) GetGreeting() string {
	if m != nil {
		return m.Greeting
	}
	return ""
}

func init() {
	proto.RegisterEnum("autonomic.ext.feed.consumer.GetStartReferenceRequest_StartReferenceType", GetStartReferenceRequest_StartReferenceType_name, GetStartReferenceRequest_StartReferenceType_value)
	proto.RegisterType((*GetFlowRequest)(nil), "autonomic.ext.feed.consumer.GetFlowRequest")
	proto.RegisterType((*ShardInfo)(nil), "autonomic.ext.feed.consumer.ShardInfo")
	proto.RegisterType((*GetFlowResponse)(nil), "autonomic.ext.feed.consumer.GetFlowResponse")
	proto.RegisterType((*GetStartReferenceRequest)(nil), "autonomic.ext.feed.consumer.GetStartReferenceRequest")
	proto.RegisterType((*GetStartReferenceResponse)(nil), "autonomic.ext.feed.consumer.GetStartReferenceResponse")
	proto.RegisterType((*GetEventsRequest)(nil), "autonomic.ext.feed.consumer.GetEventsRequest")
	proto.RegisterType((*GetEventsResponse)(nil), "autonomic.ext.feed.consumer.GetEventsResponse")
	proto.RegisterType((*FeedEvent)(nil), "autonomic.ext.feed.consumer.FeedEvent")
	proto.RegisterMapType((map[string]string)(nil), "autonomic.ext.feed.consumer.FeedEvent.TraceSpanEntry")
	proto.RegisterType((*AssetInfo)(nil), "autonomic.ext.feed.consumer.AssetInfo")
	proto.RegisterType((*VehicleAssetInfo)(nil), "autonomic.ext.feed.consumer.VehicleAssetInfo")
	proto.RegisterType((*FeedConsumerPingRequest)(nil), "autonomic.ext.feed.consumer.FeedConsumerPingRequest")
	proto.RegisterType((*FeedConsumerPingResponse)(nil), "autonomic.ext.feed.consumer.FeedConsumerPingResponse")
}

func init() {
	proto.RegisterFile("autonomic/ext/feed/consumer/consumer.proto", fileDescriptor_5bac3b738a7c7306)
}

var fileDescriptor_5bac3b738a7c7306 = []byte{
	// 1123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdf, 0x6f, 0x1b, 0xc5,
	0x13, 0xef, 0xd9, 0x69, 0xea, 0x9b, 0x24, 0xae, 0xbb, 0xdf, 0xea, 0x8b, 0xeb, 0x96, 0x36, 0x9c,
	0x0a, 0x8a, 0x80, 0x9c, 0x51, 0x4a, 0x51, 0x29, 0x08, 0xe4, 0x94, 0x4b, 0x1b, 0xb5, 0x0d, 0xd1,
	0xfa, 0x5a, 0x04, 0x3c, 0x9c, 0x36, 0x77, 0x63, 0x67, 0xd5, 0xf3, 0x9e, 0xb9, 0xdd, 0x73, 0x6a,
	0x9e, 0x79, 0x46, 0x48, 0x88, 0x77, 0xc4, 0x5f, 0xc0, 0xdf, 0xc3, 0x13, 0x7f, 0x06, 0x6f, 0xa0,
	0xdd, 0xfb, 0x11, 0x27, 0x2d, 0x76, 0x0a, 0xbc, 0xed, 0xce, 0x7e, 0x3e, 0x73, 0x33, 0x9f, 0x9d,
	0x99, 0x5b, 0x78, 0x9b, 0x65, 0x2a, 0x11, 0xc9, 0x88, 0x87, 0x5d, 0x7c, 0xae, 0xba, 0x03, 0xc4,
	0xa8, 0x1b, 0x26, 0x42, 0x66, 0x23, 0x4c, 0xab, 0x85, 0x3b, 0x4e, 0x13, 0x95, 0x90, 0xab, 0x15,
	0xd6, 0xc5, 0xe7, 0xca, 0xd5, 0x58, 0xb7, 0x84, 0x74, 0xae, 0x0c, 0x93, 0x64, 0x18, 0x63, 0xd7,
	0x40, 0x0f, 0xb2, 0x41, 0x97, 0x89, 0x69, 0xce, 0xeb, 0xdc, 0x38, 0x7d, 0xa4, 0xf8, 0x08, 0xa5,
	0x62, 0xa3, 0x71, 0x0e, 0x70, 0x6e, 0x42, 0xf3, 0x3e, 0xaa, 0x9d, 0x38, 0x39, 0xa2, 0xf8, 0x4d,
	0x86, 0x52, 0x11, 0x02, 0x4b, 0x83, 0x38, 0x39, 0x6a, 0x5b, 0xeb, 0xd6, 0x86, 0x4d, 0xcd, 0xda,
	0xf9, 0xde, 0x02, 0xbb, 0x7f, 0xc8, 0xd2, 0x68, 0x57, 0x0c, 0x12, 0xd2, 0x84, 0x1a, 0x8f, 0xcc,
	0xf9, 0x2a, 0xad, 0xf1, 0x88, 0x74, 0xa0, 0x31, 0x42, 0x29, 0xd9, 0x10, 0x65, 0xbb, 0xb6, 0x6e,
	0x6d, 0x2c, 0xd1, 0x6a, 0x4f, 0x2e, 0xc3, 0xf9, 0x83, 0xa9, 0x42, 0xd9, 0xae, 0x9b, 0x83, 0x7c,
	0x43, 0x3e, 0x85, 0xb5, 0x98, 0x49, 0x15, 0xa4, 0x18, 0x22, 0x9f, 0x60, 0xd4, 0x5e, 0x5a, 0xb7,
	0x36, 0x56, 0xb6, 0x3a, 0x6e, 0x1e, 0xae, 0x5b, 0x86, 0xeb, 0xfa, 0x65, 0xb8, 0x74, 0x55, 0x13,
	0x68, 0x81, 0x77, 0x7e, 0xb3, 0xe0, 0x62, 0x15, 0xb7, 0x1c, 0x27, 0x42, 0x22, 0xf9, 0x04, 0x96,
	0xa5, 0x8e, 0x51, 0xb6, 0xad, 0xf5, 0xfa, 0xc6, 0xca, 0xd6, 0x5b, 0xee, 0x1c, 0xd1, 0xdc, 0x2a,
	0x1d, 0x5a, 0xb0, 0xc8, 0x9b, 0xd0, 0x54, 0x89, 0x62, 0x71, 0x70, 0x2a, 0x99, 0x35, 0x63, 0x7d,
	0x5c, 0x66, 0x74, 0x03, 0x56, 0x72, 0xd8, 0x6c, 0x5e, 0x60, 0x4c, 0xdb, 0xff, 0x4d, 0x72, 0x3f,
	0xd5, 0xa1, 0x7d, 0x1f, 0x55, 0x5f, 0xb1, 0x54, 0x51, 0x1c, 0x60, 0x8a, 0x22, 0xc4, 0x39, 0xd7,
	0xa3, 0x45, 0x36, 0x39, 0x98, 0x80, 0x57, 0x69, 0xbe, 0x21, 0x43, 0x00, 0xa9, 0x5d, 0x04, 0x6a,
	0x3a, 0x46, 0x13, 0x67, 0x73, 0xeb, 0xc1, 0x5c, 0x4d, 0xfe, 0xee, 0xa3, 0xee, 0x49, 0xab, 0x3f,
	0x1d, 0x23, 0xb5, 0x8d, 0x6f, 0xbd, 0x24, 0xd7, 0xc1, 0x4e, 0xcb, 0x33, 0x93, 0xec, 0xea, 0x83,
	0x73, 0xf4, 0xd8, 0x44, 0xee, 0x82, 0x5d, 0x95, 0x5d, 0xfb, 0xfc, 0x22, 0x31, 0x34, 0xb7, 0x82,
	0x3b, 0x47, 0x40, 0x5e, 0xfc, 0x38, 0x59, 0x87, 0x6b, 0x4f, 0xf6, 0x1e, 0xee, 0x7d, 0xfe, 0xc5,
	0x5e, 0xd0, 0xf7, 0x7b, 0xd4, 0x0f, 0xa8, 0xb7, 0xe3, 0x51, 0x6f, 0xef, 0x9e, 0x17, 0xf8, 0x5f,
	0xee, 0x7b, 0xad, 0x73, 0x64, 0x15, 0x1a, 0x5e, 0x8f, 0x3e, 0xda, 0xf5, 0xfa, 0x7e, 0xcb, 0x22,
	0x00, 0xcb, 0x8f, 0x7a, 0xbe, 0x5e, 0xd7, 0xc8, 0xff, 0xe0, 0x62, 0x6f, 0xc7, 0xf7, 0xe8, 0x31,
	0xa7, 0x55, 0x27, 0x2d, 0x58, 0xed, 0xf9, 0x81, 0xbf, 0xfb, 0xd8, 0xeb, 0xfb, 0xbd, 0xc7, 0xfb,
	0xad, 0xa5, 0xed, 0x4b, 0x70, 0x31, 0x57, 0x6f, 0xcc, 0x52, 0x36, 0x42, 0x85, 0xa9, 0xf3, 0x21,
	0x5c, 0x79, 0x89, 0x42, 0x45, 0xf5, 0x5d, 0x9b, 0x15, 0x21, 0xef, 0x8d, 0x63, 0x83, 0xf3, 0xa7,
	0x05, 0xad, 0xfb, 0xa8, 0xbc, 0x09, 0x0a, 0x25, 0x5f, 0xfd, 0x2a, 0x4f, 0x38, 0xaf, 0x9f, 0x72,
	0x4e, 0xda, 0x70, 0x41, 0x0b, 0x96, 0x64, 0xca, 0xa8, 0xbf, 0x46, 0xcb, 0xad, 0xae, 0xd5, 0x30,
	0xc9, 0x84, 0x0a, 0x62, 0x3e, 0xe2, 0xca, 0x68, 0xbf, 0x46, 0xc1, 0x98, 0x1e, 0x69, 0x0b, 0x79,
	0x1d, 0x40, 0xf2, 0x6f, 0xb1, 0x38, 0x5f, 0x36, 0xe7, 0xb6, 0xb6, 0xe4, 0xc7, 0xbb, 0xf0, 0x46,
	0x84, 0x51, 0x36, 0x0e, 0xc2, 0x44, 0x28, 0x3e, 0xcc, 0x92, 0x4c, 0x06, 0x3c, 0x42, 0xa1, 0x78,
	0xc8, 0xe2, 0x00, 0x4d, 0x36, 0xed, 0x0b, 0xeb, 0xd6, 0x46, 0x83, 0x5e, 0x37, 0xc0, 0x7b, 0x15,
	0x6e, 0xb7, 0x84, 0xe5, 0x39, 0x3b, 0x7d, 0xb8, 0x34, 0x23, 0xc0, 0x71, 0xcb, 0x16, 0x4e, 0xce,
	0xd2, 0xb2, 0x3b, 0x88, 0x91, 0x71, 0x40, 0x0b, 0x96, 0xf3, 0x43, 0x1d, 0xec, 0xca, 0x3a, 0xff,
	0x0a, 0xc8, 0x9d, 0xd9, 0x2a, 0xac, 0x2d, 0x6c, 0xc9, 0x63, 0x30, 0xb9, 0x0a, 0xb6, 0xb9, 0x86,
	0xe0, 0x19, 0x4e, 0x8d, 0xfa, 0x36, 0x6d, 0x18, 0xc3, 0x43, 0x9c, 0x92, 0x5b, 0x00, 0xba, 0xbf,
	0xa2, 0x20, 0x62, 0x8a, 0x15, 0xd5, 0x7d, 0xf9, 0x05, 0xbf, 0x3d, 0x31, 0xa5, 0xb6, 0xc1, 0x7d,
	0xc6, 0x14, 0x23, 0x1e, 0x00, 0x93, 0x12, 0x55, 0xc0, 0xc5, 0x20, 0x31, 0x02, 0x2e, 0xca, 0xbd,
	0xa7, 0xe1, 0x66, 0x5c, 0xd9, 0xac, 0x5c, 0x12, 0x1f, 0x40, 0xa5, 0x2c, 0xc4, 0x40, 0x8e, 0x99,
	0x68, 0x37, 0x8c, 0x84, 0xb7, 0xcf, 0x26, 0xa1, 0xeb, 0x6b, 0x62, 0x7f, 0xcc, 0x84, 0x27, 0x54,
	0xaa, 0x83, 0x2b, 0xf7, 0x9d, 0x8f, 0xa1, 0x79, 0xf2, 0x90, 0xb4, 0xa0, 0xae, 0x53, 0xcf, 0xeb,
	0x54, 0x2f, 0x75, 0x99, 0x4e, 0x58, 0x9c, 0xa1, 0x11, 0xd2, 0xa6, 0xf9, 0xe6, 0x6e, 0xed, 0x8e,
	0xe5, 0x1c, 0x82, 0x5d, 0xc5, 0x4a, 0xbe, 0x06, 0x32, 0xc1, 0x43, 0x1e, 0xc6, 0x18, 0xcc, 0xe4,
	0x6b, 0x99, 0x7c, 0x37, 0xe7, 0x06, 0xfa, 0x34, 0xa7, 0x1d, 0xa7, 0xdd, 0x9a, 0x9c, 0xb2, 0x38,
	0x3f, 0x5b, 0xd0, 0x3a, 0x0d, 0xd3, 0xa1, 0x4e, 0xb8, 0x28, 0x43, 0x9d, 0x70, 0x41, 0x6e, 0x42,
	0xd3, 0x8c, 0xe3, 0x67, 0x22, 0x39, 0x12, 0x01, 0x4a, 0x51, 0xc4, 0x6c, 0x66, 0xee, 0x43, 0x6d,
	0xf4, 0xa4, 0x20, 0x1b, 0xd0, 0x9a, 0x41, 0xf1, 0x30, 0xe4, 0x51, 0x71, 0xd5, 0xcd, 0x0a, 0xb7,
	0xab, 0xad, 0xba, 0x6b, 0xcd, 0x40, 0x5d, 0xca, 0xbb, 0x56, 0xaf, 0xc9, 0xff, 0x61, 0x59, 0x62,
	0xca, 0x59, 0x6c, 0x0a, 0xc0, 0xa6, 0xc5, 0xce, 0x79, 0x0a, 0xaf, 0x69, 0xc5, 0xef, 0x15, 0x59,
	0xed, 0x73, 0x31, 0x2c, 0x9b, 0xff, 0x23, 0x58, 0x09, 0x63, 0x8e, 0x42, 0x05, 0xba, 0xd0, 0x0a,
	0x4d, 0xe6, 0x15, 0x24, 0xe4, 0x70, 0x6d, 0x70, 0x7e, 0xb5, 0xa0, 0xfd, 0xa2, 0xe3, 0xa2, 0xa9,
	0xfe, 0x8d, 0x67, 0x4d, 0x96, 0x98, 0x4e, 0x30, 0xcd, 0xc9, 0x8b, 0xfb, 0x04, 0x72, 0xb8, 0x21,
	0x77, 0xa0, 0x31, 0x4c, 0x11, 0x15, 0x17, 0xc3, 0xb2, 0x4f, 0xca, 0xfd, 0xd6, 0xef, 0x75, 0x68,
	0x94, 0xe1, 0x92, 0x01, 0x5c, 0x28, 0xfe, 0xde, 0xe4, 0x9d, 0x45, 0x7f, 0xa4, 0x99, 0xb7, 0x49,
	0xe7, 0xdd, 0xb3, 0x81, 0x73, 0x21, 0x9c, 0x73, 0xe4, 0x3b, 0xcb, 0x4c, 0x9d, 0x93, 0x23, 0x9b,
	0xdc, 0xfe, 0x47, 0x3f, 0xc1, 0xce, 0x07, 0xaf, 0x4a, 0xab, 0xc2, 0x10, 0x60, 0x57, 0xb3, 0x8f,
	0x6c, 0x2e, 0x72, 0x73, 0xe2, 0x27, 0xd1, 0x71, 0xcf, 0x0a, 0x2f, 0xbf, 0xf6, 0x9e, 0x45, 0x32,
	0x58, 0xd2, 0x15, 0x41, 0xde, 0x5f, 0x38, 0x0b, 0x5e, 0x52, 0x99, 0x9d, 0xdb, 0xaf, 0xc8, 0x2a,
	0x3f, 0xbc, 0xfd, 0xa3, 0x05, 0x37, 0xc2, 0x64, 0x34, 0x8f, 0xbe, 0x7d, 0xe9, 0x04, 0x5f, 0x97,
	0xd3, 0xbe, 0xf5, 0x15, 0x1d, 0x72, 0x75, 0x98, 0x1d, 0xb8, 0x61, 0x32, 0xea, 0x56, 0xe4, 0x4d,
	0xc6, 0xf5, 0xbb, 0x18, 0x53, 0xc1, 0xe2, 0x4d, 0x53, 0x78, 0xb2, 0x2b, 0xd3, 0xb0, 0x3b, 0x62,
	0x5c, 0xe4, 0xef, 0xd9, 0xee, 0x9c, 0x07, 0xf4, 0x1f, 0x96, 0xf5, 0x4b, 0xad, 0xde, 0x7b, 0xe2,
	0x1f, 0x2c, 0x1b, 0xec, 0xad, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x9e, 0xcc, 0xb6, 0x62, 0x6f,
	0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ConsumerClient is the client API for Consumer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConsumerClient interface {
	//
	//GetFlow()
	//
	//Returns a snapshot of selected statistics for a named flow.
	//
	//If the flow name is invalid or the named flow does not exist,
	//an appropriate exception is raised.
	//
	//NOTE: the Shard Identifiers returned by this call are intended
	//to be entirely opaque.
	//
	GetFlow(ctx context.Context, in *GetFlowRequest, opts ...grpc.CallOption) (*GetFlowResponse, error)
	//
	//GetStartReference()
	//
	//Given a valid flow name and a shard identifier previously
	//obtained from a GetFlow request, obtain a valid Reference that
	//can be used to start reading that shard's data for that flow
	//at the indicationed starting location.
	//
	//If the flow name is invalid or the named flow does not exist,
	//or the Shard Identifier is invalid, or the Reference is needed
	//and is invalid, an appropriate exception is raised.
	//
	//Consumers may start at the beginning, or ask only for new
	//data arriving, or start at a specified time, or start after
	//a previously consumed message using its reference.
	//
	//Operation is currently UNDEFINED if the shard identifier is
	//from the wrong flow, or if a specified reference is not from
	//the specified shard of the specified flow.
	//
	//TODO: decide if "throw an exception on mismatch" is sufficiently
	//useful to mandate the bookkeeping needed.
	GetStartReference(ctx context.Context, in *GetStartReferenceRequest, opts ...grpc.CallOption) (*GetStartReferenceResponse, error)
	//
	//GetEvents()
	//
	//Given a valid flow name, shard identifier, and reference, start
	//a stream flowing that contains the appropriate data. The stream
	//will terminate if a specified timeout is exceeded, or if the number
	//of events returned reeaches a specified limit, or if the total
	//size of the serialized data exceeds the size limit.
	//
	//If the flow name is invalid or the named flow does not exist,
	//or the Shard Identifier is invalid, or the Reference is
	//invalid, an appropriate exception is raised.
	//
	//Operation is currently UNDEFINED if the shard identifier is
	//from the wrong flow, or if the specified reference is not from
	//the specified shard of the specified flow.
	//
	//TODO: decide if "throw an exception on mismatch" is sufficiently
	//useful to mandate the bookkeeping needed.
	GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (Consumer_GetEventsClient, error)
	//
	//Ping()
	//
	//Confirm liveness of the service; report service version; and
	//allow estimation of minimum request round trip latency.
	//
	//Precision of one-way latencies will depend on the relative
	//offsets of client and server clocks.
	Ping(ctx context.Context, in *FeedConsumerPingRequest, opts ...grpc.CallOption) (*FeedConsumerPingResponse, error)
}

type consumerClient struct {
	cc grpc.ClientConnInterface
}

func NewConsumerClient(cc grpc.ClientConnInterface) ConsumerClient {
	return &consumerClient{cc}
}

func (c *consumerClient) GetFlow(ctx context.Context, in *GetFlowRequest, opts ...grpc.CallOption) (*GetFlowResponse, error) {
	out := new(GetFlowResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.feed.consumer.Consumer/GetFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consumerClient) GetStartReference(ctx context.Context, in *GetStartReferenceRequest, opts ...grpc.CallOption) (*GetStartReferenceResponse, error) {
	out := new(GetStartReferenceResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.feed.consumer.Consumer/GetStartReference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consumerClient) GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (Consumer_GetEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Consumer_serviceDesc.Streams[0], "/autonomic.ext.feed.consumer.Consumer/GetEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &consumerGetEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Consumer_GetEventsClient interface {
	Recv() (*GetEventsResponse, error)
	grpc.ClientStream
}

type consumerGetEventsClient struct {
	grpc.ClientStream
}

func (x *consumerGetEventsClient) Recv() (*GetEventsResponse, error) {
	m := new(GetEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *consumerClient) Ping(ctx context.Context, in *FeedConsumerPingRequest, opts ...grpc.CallOption) (*FeedConsumerPingResponse, error) {
	out := new(FeedConsumerPingResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.feed.consumer.Consumer/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsumerServer is the server API for Consumer service.
type ConsumerServer interface {
	//
	//GetFlow()
	//
	//Returns a snapshot of selected statistics for a named flow.
	//
	//If the flow name is invalid or the named flow does not exist,
	//an appropriate exception is raised.
	//
	//NOTE: the Shard Identifiers returned by this call are intended
	//to be entirely opaque.
	//
	GetFlow(context.Context, *GetFlowRequest) (*GetFlowResponse, error)
	//
	//GetStartReference()
	//
	//Given a valid flow name and a shard identifier previously
	//obtained from a GetFlow request, obtain a valid Reference that
	//can be used to start reading that shard's data for that flow
	//at the indicationed starting location.
	//
	//If the flow name is invalid or the named flow does not exist,
	//or the Shard Identifier is invalid, or the Reference is needed
	//and is invalid, an appropriate exception is raised.
	//
	//Consumers may start at the beginning, or ask only for new
	//data arriving, or start at a specified time, or start after
	//a previously consumed message using its reference.
	//
	//Operation is currently UNDEFINED if the shard identifier is
	//from the wrong flow, or if a specified reference is not from
	//the specified shard of the specified flow.
	//
	//TODO: decide if "throw an exception on mismatch" is sufficiently
	//useful to mandate the bookkeeping needed.
	GetStartReference(context.Context, *GetStartReferenceRequest) (*GetStartReferenceResponse, error)
	//
	//GetEvents()
	//
	//Given a valid flow name, shard identifier, and reference, start
	//a stream flowing that contains the appropriate data. The stream
	//will terminate if a specified timeout is exceeded, or if the number
	//of events returned reeaches a specified limit, or if the total
	//size of the serialized data exceeds the size limit.
	//
	//If the flow name is invalid or the named flow does not exist,
	//or the Shard Identifier is invalid, or the Reference is
	//invalid, an appropriate exception is raised.
	//
	//Operation is currently UNDEFINED if the shard identifier is
	//from the wrong flow, or if the specified reference is not from
	//the specified shard of the specified flow.
	//
	//TODO: decide if "throw an exception on mismatch" is sufficiently
	//useful to mandate the bookkeeping needed.
	GetEvents(*GetEventsRequest, Consumer_GetEventsServer) error
	//
	//Ping()
	//
	//Confirm liveness of the service; report service version; and
	//allow estimation of minimum request round trip latency.
	//
	//Precision of one-way latencies will depend on the relative
	//offsets of client and server clocks.
	Ping(context.Context, *FeedConsumerPingRequest) (*FeedConsumerPingResponse, error)
}

// UnimplementedConsumerServer can be embedded to have forward compatible implementations.
type UnimplementedConsumerServer struct {
}

func (*UnimplementedConsumerServer) GetFlow(ctx context.Context, req *GetFlowRequest) (*GetFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlow not implemented")
}
func (*UnimplementedConsumerServer) GetStartReference(ctx context.Context, req *GetStartReferenceRequest) (*GetStartReferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStartReference not implemented")
}
func (*UnimplementedConsumerServer) GetEvents(req *GetEventsRequest, srv Consumer_GetEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEvents not implemented")
}
func (*UnimplementedConsumerServer) Ping(ctx context.Context, req *FeedConsumerPingRequest) (*FeedConsumerPingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

func RegisterConsumerServer(s *grpc.Server, srv ConsumerServer) {
	s.RegisterService(&_Consumer_serviceDesc, srv)
}

func _Consumer_GetFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerServer).GetFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.feed.consumer.Consumer/GetFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerServer).GetFlow(ctx, req.(*GetFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consumer_GetStartReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStartReferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerServer).GetStartReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.feed.consumer.Consumer/GetStartReference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerServer).GetStartReference(ctx, req.(*GetStartReferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consumer_GetEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConsumerServer).GetEvents(m, &consumerGetEventsServer{stream})
}

type Consumer_GetEventsServer interface {
	Send(*GetEventsResponse) error
	grpc.ServerStream
}

type consumerGetEventsServer struct {
	grpc.ServerStream
}

func (x *consumerGetEventsServer) Send(m *GetEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Consumer_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedConsumerPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.feed.consumer.Consumer/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerServer).Ping(ctx, req.(*FeedConsumerPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Consumer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "autonomic.ext.feed.consumer.Consumer",
	HandlerType: (*ConsumerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFlow",
			Handler:    _Consumer_GetFlow_Handler,
		},
		{
			MethodName: "GetStartReference",
			Handler:    _Consumer_GetStartReference_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Consumer_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetEvents",
			Handler:       _Consumer_GetEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "autonomic/ext/feed/consumer/consumer.proto",
}
