/*-
 * ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 * Autonomic Proprietary 1.0
 * ——————————————————————————————————————————————————————————————————————————————
 * Copyright (C) 2020 Autonomic, LLC - All rights reserved
 * ——————————————————————————————————————————————————————————————————————————————
 * Proprietary and confidential.
 *
 * NOTICE:  All information contained herein is, and remains the property of
 * Autonomic, LLC and its suppliers, if any.  The intellectual and technical
 * concepts contained herein are proprietary to Autonomic, LLC and its suppliers
 * and may be covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this information
 * or reproduction of this material is strictly forbidden unless prior written
 * permission is obtained from Autonomic, LLC.
 *
 * Unauthorized copy of this file, via any medium is strictly prohibited.
 * ______________________________________________________________________________
 */
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: autonomic/ext/bytestream/bytestream.proto

package bytestream

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google/api"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AccessPolicy int32

const (
	AccessPolicy_ACCESS_UNSET AccessPolicy = 0
	AccessPolicy_ACCESS_ALLOW AccessPolicy = 1
	AccessPolicy_ACCESS_DENY  AccessPolicy = 2
)

var AccessPolicy_name = map[int32]string{
	0: "ACCESS_UNSET",
	1: "ACCESS_ALLOW",
	2: "ACCESS_DENY",
}

var AccessPolicy_value = map[string]int32{
	"ACCESS_UNSET": 0,
	"ACCESS_ALLOW": 1,
	"ACCESS_DENY":  2,
}

func (x AccessPolicy) String() string {
	return proto.EnumName(AccessPolicy_name, int32(x))
}

func (AccessPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{0}
}

// Request object for ByteStream.Read.
type ReadRequest struct {
	// The name of the resource to read.
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// The offset for the first byte to return in the read, relative to the start
	// of the resource.
	//
	// A `read_offset` that is negative or greater than the size of the resource
	// will cause an `OUT_OF_RANGE` error.
	ReadOffset int64 `protobuf:"varint,2,opt,name=read_offset,json=readOffset,proto3" json:"read_offset,omitempty"`
	// The maximum number of `data` bytes the server is allowed to return in the
	// sum of all `ReadResponse` messages. A `read_limit` of zero indicates that
	// there is no limit, and a negative `read_limit` will cause an error.
	//
	// If the stream returns fewer bytes than allowed by the `read_limit` and no
	// error occurred, the stream includes all data from the `read_offset` to the
	// end of the resource.
	ReadLimit int64 `protobuf:"varint,3,opt,name=read_limit,json=readLimit,proto3" json:"read_limit,omitempty"`
	// The maximum number of `data` bytes the server is allowed to return in a
	// single `ReadResponse` message. A `read_chunk_limit` of zero indicates that
	// that there is no limit per `ReadResponse`, and a negative
	// `read_chunk_limit` will cause an error.
	ReadChunkLimit       int64    `protobuf:"varint,4,opt,name=read_chunk_limit,json=readChunkLimit,proto3" json:"read_chunk_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{0}
}

func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadRequest.Unmarshal(m, b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return xxx_messageInfo_ReadRequest.Size(m)
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

func (m *ReadRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *ReadRequest) GetReadOffset() int64 {
	if m != nil {
		return m.ReadOffset
	}
	return 0
}

func (m *ReadRequest) GetReadLimit() int64 {
	if m != nil {
		return m.ReadLimit
	}
	return 0
}

func (m *ReadRequest) GetReadChunkLimit() int64 {
	if m != nil {
		return m.ReadChunkLimit
	}
	return 0
}

// Response object for ByteStream.Read.
type ReadResponse struct {
	// A portion of the data for the resource. The service **may** leave `data`
	// empty for any given `ReadResponse`. This enables the service to inform the
	// client that the request is still live while it is running an operation to
	// generate more data.
	Data                 []byte   `protobuf:"bytes,10,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadResponse) Reset()         { *m = ReadResponse{} }
func (m *ReadResponse) String() string { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()    {}
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{1}
}

func (m *ReadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadResponse.Unmarshal(m, b)
}
func (m *ReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadResponse.Marshal(b, m, deterministic)
}
func (m *ReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResponse.Merge(m, src)
}
func (m *ReadResponse) XXX_Size() int {
	return xxx_messageInfo_ReadResponse.Size(m)
}
func (m *ReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResponse proto.InternalMessageInfo

func (m *ReadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request object for ByteStream.Write.
type WriteRequest struct {
	// The name of the resource to write. This **must** be set on the first
	// `WriteRequest` of each `Write()` action. If it is set on subsequent calls,
	// it **must** match the value of the first request.
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// The source of the write. This **must** be set on the first `WriteRequest`
	// of each `Write()` action. If it is set on subsequent calls, it **must**
	// match the value of the first request.
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	// Metadata to maintain about the resource. This should **only** be set on
	// the first `WriteRequest` of each `Write()` action. If it is set on
	// subsequent calls it will be ignored.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The offset from the beginning of the resource at which the data should be
	// written. It is required on all `WriteRequest`s.
	//
	// In the first `WriteRequest` of a `Write()` action, it indicates
	// the initial offset for the `Write()` call. The value **must** be equal to
	// the `committed_size` that a call to `QueryWriteStatus()` would return.
	//
	// On subsequent calls, this value **must** be set and **must** be equal to
	// the sum of the first `write_offset` and the sizes of all `data` bundles
	// sent previously on this stream.
	//
	// An incorrect value will cause an error.
	WriteOffset int64 `protobuf:"varint,4,opt,name=write_offset,json=writeOffset,proto3" json:"write_offset,omitempty"`
	// If `true`, this indicates that the write is complete. Sending any
	// `WriteRequest`s subsequent to one in which `finish_write` is `true` will
	// cause an error.
	FinishWrite bool `protobuf:"varint,5,opt,name=finish_write,json=finishWrite,proto3" json:"finish_write,omitempty"`
	// A portion of the data for the resource. The client **may** leave `data`
	// empty for any given `WriteRequest`. This enables the client to inform the
	// service that the request is still live while it is running an operation to
	// generate more data.
	Data                 []byte   `protobuf:"bytes,10,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{2}
}

func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WriteRequest.Unmarshal(m, b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
}
func (m *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(m, src)
}
func (m *WriteRequest) XXX_Size() int {
	return xxx_messageInfo_WriteRequest.Size(m)
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

func (m *WriteRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *WriteRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *WriteRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *WriteRequest) GetWriteOffset() int64 {
	if m != nil {
		return m.WriteOffset
	}
	return 0
}

func (m *WriteRequest) GetFinishWrite() bool {
	if m != nil {
		return m.FinishWrite
	}
	return false
}

func (m *WriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Response object for ByteStream.Write.
type WriteResponse struct {
	// The number of bytes that have been processed for the given resource.
	CommittedSize        int64    `protobuf:"varint,1,opt,name=committed_size,json=committedSize,proto3" json:"committed_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteResponse) Reset()         { *m = WriteResponse{} }
func (m *WriteResponse) String() string { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()    {}
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{3}
}

func (m *WriteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WriteResponse.Unmarshal(m, b)
}
func (m *WriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WriteResponse.Marshal(b, m, deterministic)
}
func (m *WriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteResponse.Merge(m, src)
}
func (m *WriteResponse) XXX_Size() int {
	return xxx_messageInfo_WriteResponse.Size(m)
}
func (m *WriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteResponse proto.InternalMessageInfo

func (m *WriteResponse) GetCommittedSize() int64 {
	if m != nil {
		return m.CommittedSize
	}
	return 0
}

// Request object for ByteStream.QueryWriteStatus.
type QueryWriteStatusRequest struct {
	// The name of the resource whose write status is being requested.
	ResourceName         string   `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryWriteStatusRequest) Reset()         { *m = QueryWriteStatusRequest{} }
func (m *QueryWriteStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryWriteStatusRequest) ProtoMessage()    {}
func (*QueryWriteStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{4}
}

func (m *QueryWriteStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryWriteStatusRequest.Unmarshal(m, b)
}
func (m *QueryWriteStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryWriteStatusRequest.Marshal(b, m, deterministic)
}
func (m *QueryWriteStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryWriteStatusRequest.Merge(m, src)
}
func (m *QueryWriteStatusRequest) XXX_Size() int {
	return xxx_messageInfo_QueryWriteStatusRequest.Size(m)
}
func (m *QueryWriteStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryWriteStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryWriteStatusRequest proto.InternalMessageInfo

func (m *QueryWriteStatusRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

// Response object for ByteStream.QueryWriteStatus.
type QueryWriteStatusResponse struct {
	// The number of bytes that have been processed for the given resource.
	CommittedSize int64 `protobuf:"varint,1,opt,name=committed_size,json=committedSize,proto3" json:"committed_size,omitempty"`
	// `complete` is `true` only if the client has sent a `WriteRequest` with
	// `finish_write` set to true, and the server has processed that request.
	Complete bool `protobuf:"varint,2,opt,name=complete,proto3" json:"complete,omitempty"`
	// The URI to read the resource back via HTTP, only populated once
	// `complete` is `true`.
	Uri string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	//Metadata about the resource, if set at upload.
	Tags                 map[string]string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QueryWriteStatusResponse) Reset()         { *m = QueryWriteStatusResponse{} }
func (m *QueryWriteStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryWriteStatusResponse) ProtoMessage()    {}
func (*QueryWriteStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{5}
}

func (m *QueryWriteStatusResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryWriteStatusResponse.Unmarshal(m, b)
}
func (m *QueryWriteStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryWriteStatusResponse.Marshal(b, m, deterministic)
}
func (m *QueryWriteStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryWriteStatusResponse.Merge(m, src)
}
func (m *QueryWriteStatusResponse) XXX_Size() int {
	return xxx_messageInfo_QueryWriteStatusResponse.Size(m)
}
func (m *QueryWriteStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryWriteStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryWriteStatusResponse proto.InternalMessageInfo

func (m *QueryWriteStatusResponse) GetCommittedSize() int64 {
	if m != nil {
		return m.CommittedSize
	}
	return 0
}

func (m *QueryWriteStatusResponse) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

func (m *QueryWriteStatusResponse) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *QueryWriteStatusResponse) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Request object for ByteStream.ResourceAdmin.
type ResourceAdminRequest struct {
	// name for a ByteStream resource
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// Access policy for the specified resource
	Policy               *BytestreamResourceAccessPolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ResourceAdminRequest) Reset()         { *m = ResourceAdminRequest{} }
func (m *ResourceAdminRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceAdminRequest) ProtoMessage()    {}
func (*ResourceAdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{6}
}

func (m *ResourceAdminRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceAdminRequest.Unmarshal(m, b)
}
func (m *ResourceAdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceAdminRequest.Marshal(b, m, deterministic)
}
func (m *ResourceAdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceAdminRequest.Merge(m, src)
}
func (m *ResourceAdminRequest) XXX_Size() int {
	return xxx_messageInfo_ResourceAdminRequest.Size(m)
}
func (m *ResourceAdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceAdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceAdminRequest proto.InternalMessageInfo

func (m *ResourceAdminRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *ResourceAdminRequest) GetPolicy() *BytestreamResourceAccessPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// Defines access policy to bytestream resources for both authenticated and unauthenticated access
type BytestreamResourceAccessPolicy struct {
	// If `ALLOW`, the resource will be made publicly available over unauthenticated endpoints
	// If `DENY`, the resource will be made not publicly available to unauthenticated endpoints
	UnauthenticatedAccessPolicy AccessPolicy `protobuf:"varint,1,opt,name=unauthenticated_access_policy,json=unauthenticatedAccessPolicy,proto3,enum=autonomic.ext.bytestream.AccessPolicy" json:"unauthenticated_access_policy,omitempty"`
	// If `ALLOW`, the resource will be made publicly available via authenticated gRPC read() calls.
	// If `DENY`, the resource will be made not publicly available via authenticated gRPC read() calls.
	AuthenticatedAccessPolicy AccessPolicy `protobuf:"varint,2,opt,name=authenticated_access_policy,json=authenticatedAccessPolicy,proto3,enum=autonomic.ext.bytestream.AccessPolicy" json:"authenticated_access_policy,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}     `json:"-"`
	XXX_unrecognized          []byte       `json:"-"`
	XXX_sizecache             int32        `json:"-"`
}

func (m *BytestreamResourceAccessPolicy) Reset()         { *m = BytestreamResourceAccessPolicy{} }
func (m *BytestreamResourceAccessPolicy) String() string { return proto.CompactTextString(m) }
func (*BytestreamResourceAccessPolicy) ProtoMessage()    {}
func (*BytestreamResourceAccessPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{7}
}

func (m *BytestreamResourceAccessPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BytestreamResourceAccessPolicy.Unmarshal(m, b)
}
func (m *BytestreamResourceAccessPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BytestreamResourceAccessPolicy.Marshal(b, m, deterministic)
}
func (m *BytestreamResourceAccessPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BytestreamResourceAccessPolicy.Merge(m, src)
}
func (m *BytestreamResourceAccessPolicy) XXX_Size() int {
	return xxx_messageInfo_BytestreamResourceAccessPolicy.Size(m)
}
func (m *BytestreamResourceAccessPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_BytestreamResourceAccessPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_BytestreamResourceAccessPolicy proto.InternalMessageInfo

func (m *BytestreamResourceAccessPolicy) GetUnauthenticatedAccessPolicy() AccessPolicy {
	if m != nil {
		return m.UnauthenticatedAccessPolicy
	}
	return AccessPolicy_ACCESS_UNSET
}

func (m *BytestreamResourceAccessPolicy) GetAuthenticatedAccessPolicy() AccessPolicy {
	if m != nil {
		return m.AuthenticatedAccessPolicy
	}
	return AccessPolicy_ACCESS_UNSET
}

// Response object for ByteStream.ResourceAdmin.
type ResourceAdminResponse struct {
	// Updated access policy
	UpdatedPolicy        *BytestreamResourceAccessPolicy `protobuf:"bytes,1,opt,name=updated_policy,json=updatedPolicy,proto3" json:"updated_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ResourceAdminResponse) Reset()         { *m = ResourceAdminResponse{} }
func (m *ResourceAdminResponse) String() string { return proto.CompactTextString(m) }
func (*ResourceAdminResponse) ProtoMessage()    {}
func (*ResourceAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{8}
}

func (m *ResourceAdminResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceAdminResponse.Unmarshal(m, b)
}
func (m *ResourceAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceAdminResponse.Marshal(b, m, deterministic)
}
func (m *ResourceAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceAdminResponse.Merge(m, src)
}
func (m *ResourceAdminResponse) XXX_Size() int {
	return xxx_messageInfo_ResourceAdminResponse.Size(m)
}
func (m *ResourceAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceAdminResponse proto.InternalMessageInfo

func (m *ResourceAdminResponse) GetUpdatedPolicy() *BytestreamResourceAccessPolicy {
	if m != nil {
		return m.UpdatedPolicy
	}
	return nil
}

// Request to return current Resource administration settings
type QueryResourceAdminRequest struct {
	// the name of the resource
	ResourceName         string   `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryResourceAdminRequest) Reset()         { *m = QueryResourceAdminRequest{} }
func (m *QueryResourceAdminRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResourceAdminRequest) ProtoMessage()    {}
func (*QueryResourceAdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{9}
}

func (m *QueryResourceAdminRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryResourceAdminRequest.Unmarshal(m, b)
}
func (m *QueryResourceAdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryResourceAdminRequest.Marshal(b, m, deterministic)
}
func (m *QueryResourceAdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResourceAdminRequest.Merge(m, src)
}
func (m *QueryResourceAdminRequest) XXX_Size() int {
	return xxx_messageInfo_QueryResourceAdminRequest.Size(m)
}
func (m *QueryResourceAdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResourceAdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResourceAdminRequest proto.InternalMessageInfo

func (m *QueryResourceAdminRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

type QueryResourceAdminResponse struct {
	// This field is only populated if status is set to `SUCCESS`.
	AccessPolicy         *BytestreamResourceAccessPolicy `protobuf:"bytes,2,opt,name=access_policy,json=accessPolicy,proto3" json:"access_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *QueryResourceAdminResponse) Reset()         { *m = QueryResourceAdminResponse{} }
func (m *QueryResourceAdminResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResourceAdminResponse) ProtoMessage()    {}
func (*QueryResourceAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46e6e888b08e7275, []int{10}
}

func (m *QueryResourceAdminResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryResourceAdminResponse.Unmarshal(m, b)
}
func (m *QueryResourceAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryResourceAdminResponse.Marshal(b, m, deterministic)
}
func (m *QueryResourceAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResourceAdminResponse.Merge(m, src)
}
func (m *QueryResourceAdminResponse) XXX_Size() int {
	return xxx_messageInfo_QueryResourceAdminResponse.Size(m)
}
func (m *QueryResourceAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResourceAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResourceAdminResponse proto.InternalMessageInfo

func (m *QueryResourceAdminResponse) GetAccessPolicy() *BytestreamResourceAccessPolicy {
	if m != nil {
		return m.AccessPolicy
	}
	return nil
}

func init() {
	proto.RegisterEnum("autonomic.ext.bytestream.AccessPolicy", AccessPolicy_name, AccessPolicy_value)
	proto.RegisterType((*ReadRequest)(nil), "autonomic.ext.bytestream.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "autonomic.ext.bytestream.ReadResponse")
	proto.RegisterType((*WriteRequest)(nil), "autonomic.ext.bytestream.WriteRequest")
	proto.RegisterMapType((map[string]string)(nil), "autonomic.ext.bytestream.WriteRequest.TagsEntry")
	proto.RegisterType((*WriteResponse)(nil), "autonomic.ext.bytestream.WriteResponse")
	proto.RegisterType((*QueryWriteStatusRequest)(nil), "autonomic.ext.bytestream.QueryWriteStatusRequest")
	proto.RegisterType((*QueryWriteStatusResponse)(nil), "autonomic.ext.bytestream.QueryWriteStatusResponse")
	proto.RegisterMapType((map[string]string)(nil), "autonomic.ext.bytestream.QueryWriteStatusResponse.TagsEntry")
	proto.RegisterType((*ResourceAdminRequest)(nil), "autonomic.ext.bytestream.ResourceAdminRequest")
	proto.RegisterType((*BytestreamResourceAccessPolicy)(nil), "autonomic.ext.bytestream.BytestreamResourceAccessPolicy")
	proto.RegisterType((*ResourceAdminResponse)(nil), "autonomic.ext.bytestream.ResourceAdminResponse")
	proto.RegisterType((*QueryResourceAdminRequest)(nil), "autonomic.ext.bytestream.QueryResourceAdminRequest")
	proto.RegisterType((*QueryResourceAdminResponse)(nil), "autonomic.ext.bytestream.QueryResourceAdminResponse")
}

func init() {
	proto.RegisterFile("autonomic/ext/bytestream/bytestream.proto", fileDescriptor_46e6e888b08e7275)
}

var fileDescriptor_46e6e888b08e7275 = []byte{
	// 835 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x51, 0x6f, 0x1b, 0x45,
	0x10, 0x66, 0x6d, 0x27, 0x8a, 0xc7, 0x67, 0xd7, 0x5a, 0x15, 0xb8, 0xba, 0x2d, 0xb8, 0x87, 0x1a,
	0x0c, 0x52, 0xef, 0x8a, 0x8b, 0xa0, 0x42, 0x08, 0xe1, 0xb8, 0x7e, 0x8b, 0x12, 0x73, 0x4e, 0x15,
	0x51, 0x09, 0x9d, 0x36, 0xe7, 0xb5, 0xbd, 0xd4, 0x77, 0x6b, 0x6e, 0xf7, 0x20, 0x2e, 0x3f, 0x80,
	0x07, 0xc4, 0x3f, 0xe0, 0x09, 0xf1, 0x37, 0xf8, 0x57, 0x3c, 0x20, 0x9e, 0xaa, 0xdb, 0x5b, 0x3b,
	0x8e, 0xe3, 0x4b, 0x72, 0xc9, 0xdb, 0xce, 0xb7, 0x33, 0xf3, 0xcd, 0x7c, 0x33, 0xda, 0x3b, 0xf8,
	0x84, 0xc4, 0x92, 0x87, 0x3c, 0x60, 0xbe, 0x43, 0x4f, 0xa5, 0x73, 0x32, 0x97, 0x54, 0xc8, 0x88,
	0x92, 0x60, 0xe5, 0x68, 0xcf, 0x22, 0x2e, 0x39, 0x36, 0x97, 0xae, 0x36, 0x3d, 0x95, 0xf6, 0xd9,
	0x7d, 0xe3, 0xc1, 0x98, 0xf3, 0xf1, 0x94, 0x3a, 0x64, 0xc6, 0x1c, 0x12, 0x86, 0x5c, 0x12, 0xc9,
	0x78, 0x28, 0xd2, 0x38, 0xeb, 0x4f, 0x04, 0x15, 0x97, 0x92, 0xa1, 0x4b, 0x7f, 0x8a, 0xa9, 0x90,
	0xf8, 0x23, 0xa8, 0x46, 0x54, 0xf0, 0x38, 0xf2, 0xa9, 0x17, 0x92, 0x80, 0x9a, 0xa8, 0x89, 0x5a,
	0x65, 0xd7, 0x58, 0x80, 0x07, 0x24, 0xa0, 0xf8, 0x43, 0xa8, 0x44, 0x94, 0x0c, 0x3d, 0x3e, 0x1a,
	0x09, 0x2a, 0xcd, 0x42, 0x13, 0xb5, 0x8a, 0x2e, 0x24, 0xd0, 0xa1, 0x42, 0xf0, 0x43, 0x50, 0x96,
	0x37, 0x65, 0x01, 0x93, 0x66, 0x51, 0xdd, 0x97, 0x13, 0x64, 0x3f, 0x01, 0x70, 0x0b, 0xea, 0xea,
	0xda, 0x9f, 0xc4, 0xe1, 0x6b, 0xed, 0x54, 0x52, 0x4e, 0xb5, 0x04, 0xef, 0x26, 0xb0, 0xf2, 0xb4,
	0x2c, 0x30, 0xd2, 0xea, 0xc4, 0x8c, 0x87, 0x82, 0x62, 0x0c, 0xa5, 0x21, 0x91, 0xc4, 0x84, 0x26,
	0x6a, 0x19, 0xae, 0x3a, 0x5b, 0x7f, 0x17, 0xc0, 0x38, 0x8e, 0x98, 0xa4, 0xb9, 0x7a, 0x78, 0x0f,
	0xb6, 0x53, 0x4b, 0x95, 0x5f, 0x76, 0xb5, 0x85, 0x5f, 0x40, 0x49, 0x92, 0xb1, 0x30, 0x8b, 0xcd,
	0x62, 0xab, 0xd2, 0x7e, 0x6a, 0x67, 0xe9, 0x6a, 0xaf, 0x52, 0xda, 0x47, 0x64, 0x2c, 0x7a, 0xa1,
	0x8c, 0xe6, 0xae, 0x8a, 0xc6, 0x8f, 0xc0, 0xf8, 0x25, 0xb9, 0x5f, 0x48, 0x94, 0x76, 0x57, 0x51,
	0x98, 0xd6, 0xe8, 0x11, 0x18, 0x23, 0x16, 0x32, 0x31, 0xf1, 0x14, 0x6a, 0x6e, 0x35, 0x51, 0x6b,
	0xc7, 0xad, 0xa4, 0x98, 0x4a, 0xbe, 0xa9, 0xdb, 0xc6, 0x97, 0x50, 0x5e, 0x92, 0xe1, 0x3a, 0x14,
	0x5f, 0xd3, 0xb9, 0xee, 0x2f, 0x39, 0xe2, 0xbb, 0xb0, 0xf5, 0x33, 0x99, 0xc6, 0x8b, 0xae, 0x52,
	0xe3, 0xab, 0xc2, 0x73, 0x64, 0x7d, 0x01, 0x55, 0x5d, 0xb2, 0xd6, 0xf2, 0x31, 0xd4, 0x7c, 0x1e,
	0x04, 0x4c, 0x4a, 0x3a, 0xf4, 0x04, 0x7b, 0x93, 0xea, 0x54, 0x74, 0xab, 0x4b, 0x74, 0xc0, 0xde,
	0x50, 0xeb, 0x1b, 0x78, 0xff, 0xbb, 0x98, 0x46, 0x73, 0x15, 0x3c, 0x90, 0x44, 0xc6, 0x22, 0x8f,
	0xd0, 0xd6, 0xff, 0x08, 0xcc, 0x8b, 0x09, 0x72, 0xd5, 0x80, 0x1b, 0xb0, 0xe3, 0xf3, 0x60, 0x36,
	0xa5, 0x32, 0x6d, 0x6c, 0xc7, 0x5d, 0xda, 0x89, 0x06, 0x71, 0xc4, 0xd4, 0x92, 0x95, 0xdd, 0xe4,
	0x88, 0xfb, 0x7a, 0x84, 0x25, 0x35, 0xc2, 0xaf, 0xb3, 0x47, 0x98, 0x55, 0xd6, 0xfa, 0x38, 0x6f,
	0x2e, 0xfa, 0x1f, 0x08, 0xee, 0xba, 0x5a, 0x8d, 0xce, 0x30, 0x60, 0x61, 0xae, 0x1d, 0xed, 0xc3,
	0xf6, 0x8c, 0x4f, 0x99, 0x3f, 0x57, 0x89, 0x2b, 0xed, 0xe7, 0xd9, 0xad, 0xec, 0x2d, 0x8f, 0x4b,
	0x3a, 0xdf, 0xa7, 0x42, 0xf4, 0x55, 0xbc, 0xab, 0xf3, 0x58, 0xff, 0x22, 0xf8, 0xe0, 0x72, 0x57,
	0xfc, 0x23, 0x3c, 0x8c, 0x43, 0x12, 0xcb, 0x09, 0x0d, 0x25, 0xf3, 0x49, 0x32, 0x18, 0xa2, 0xee,
	0x3d, 0x5d, 0x4b, 0x52, 0x69, 0xad, 0xbd, 0x9b, 0x5d, 0xcb, 0x39, 0xe6, 0xfb, 0x6b, 0xc9, 0xce,
	0x71, 0x8d, 0xe0, 0xfe, 0x65, 0x4c, 0x85, 0x5c, 0x4c, 0xf7, 0x32, 0x79, 0xac, 0x53, 0x78, 0x77,
	0x6d, 0x0a, 0x7a, 0xff, 0x3c, 0xa8, 0xc5, 0xb3, 0xa1, 0xa2, 0x5e, 0xe9, 0xee, 0x36, 0x4a, 0x57,
	0x75, 0x3e, 0xcd, 0xfc, 0x2d, 0xdc, 0x53, 0x5b, 0x76, 0xe3, 0x25, 0xb0, 0x7e, 0x85, 0xc6, 0xa6,
	0x0c, 0xba, 0x81, 0x1f, 0xa0, 0x7a, 0x51, 0xb3, 0xdb, 0xd4, 0x6f, 0x90, 0x15, 0xeb, 0xd3, 0x2e,
	0x18, 0xe7, 0x06, 0x56, 0x07, 0xa3, 0xd3, 0xed, 0xf6, 0x06, 0x03, 0xef, 0xe5, 0xc1, 0xa0, 0x77,
	0x54, 0x7f, 0x67, 0x05, 0xe9, 0xec, 0xef, 0x1f, 0x1e, 0xd7, 0x11, 0xbe, 0x03, 0x15, 0x8d, 0xbc,
	0xe8, 0x1d, 0x7c, 0x5f, 0x2f, 0xb4, 0xff, 0x29, 0x01, 0x24, 0xac, 0x03, 0xc5, 0x8a, 0x8f, 0xa1,
	0x94, 0xbc, 0xe9, 0xf8, 0x71, 0x76, 0x8d, 0x2b, 0x5f, 0xa4, 0xc6, 0xee, 0x55, 0x6e, 0xa9, 0x12,
	0x4f, 0x11, 0x7e, 0x05, 0x5b, 0xe9, 0xbb, 0xb9, 0x7b, 0xbd, 0x57, 0xbb, 0xf1, 0xf1, 0x95, 0x7e,
	0x69, 0xee, 0x16, 0xc2, 0x73, 0xa8, 0xaf, 0xbf, 0x16, 0xf8, 0xb3, 0x3c, 0x2f, 0x4b, 0xca, 0xd8,
	0xce, 0xff, 0x18, 0xe1, 0x18, 0xb0, 0x9a, 0x39, 0x13, 0x92, 0x46, 0x8b, 0x99, 0x61, 0xfb, 0x32,
	0x59, 0x2e, 0xee, 0x5a, 0xc3, 0xb9, 0xb6, 0xbf, 0xa6, 0xfd, 0x0d, 0x6d, 0x5a, 0xbc, 0x01, 0x95,
	0x92, 0x85, 0x63, 0x81, 0x9f, 0x5d, 0xd1, 0xc9, 0xc6, 0x22, 0x3e, 0xcf, 0x17, 0x94, 0x56, 0xb2,
	0xf7, 0x3b, 0x82, 0x07, 0x3e, 0x0f, 0x32, 0x63, 0xf7, 0xee, 0x9c, 0x6d, 0x57, 0x3f, 0xf9, 0xab,
	0xe9, 0xa3, 0x57, 0x87, 0x63, 0x26, 0x27, 0xf1, 0x89, 0xed, 0xf3, 0xc0, 0x59, 0xc6, 0x3d, 0x21,
	0x2c, 0xf9, 0x91, 0xa2, 0x51, 0x48, 0xa6, 0x4f, 0xd4, 0xff, 0x8f, 0x70, 0x44, 0xe4, 0x3b, 0x01,
	0x61, 0xa1, 0xa3, 0x6c, 0x27, 0xeb, 0x8f, 0xeb, 0x3f, 0x84, 0xfe, 0x2a, 0x14, 0x3b, 0x2f, 0x8f,
	0x4e, 0xb6, 0x95, 0xe3, 0xb3, 0xb7, 0x01, 0x00, 0x00, 0xff, 0xff, 0x78, 0xc1, 0xe0, 0x8a, 0x9d,
	0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ByteStreamClient is the client API for ByteStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ByteStreamClient interface {
	// `Read()` is used to retrieve the contents of a resource as a sequence
	// of bytes. The bytes are returned in a sequence of responses, and the
	// responses are delivered as the results of a server-side streaming RPC.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (ByteStream_ReadClient, error)
	// `Write()` is used to send the contents of a resource as a sequence of
	// bytes. The bytes are sent in a sequence of request protos of a client-side
	// streaming RPC.
	//
	// A `Write()` action is resumable. If there is an error or the connection is
	// broken during the `Write()`, the client should check the status of the
	// `Write()` by calling `QueryWriteStatus()` and continue writing from the
	// returned `committed_size`. This may be less than the amount of data the
	// client previously sent.
	//
	// Calling `Write()` on a resource name that was previously written and
	// finalized could cause an error, depending on whether the underlying service
	// allows over-writing of previously written resources.
	//
	// When the client closes the request channel, the service will respond with
	// a `WriteResponse`. The service will not view the resource as `complete`
	// until the client has sent a `WriteRequest` with `finish_write` set to
	// `true`. Sending any requests on a stream after sending a request with
	// `finish_write` set to `true` will cause an error. The client **should**
	// check the `WriteResponse` it receives to determine how much data the
	// service was able to commit and whether the service views the resource as
	// `complete` or not.
	Write(ctx context.Context, opts ...grpc.CallOption) (ByteStream_WriteClient, error)
	// `QueryWriteStatus()` is used to find the `committed_size` for a resource
	// that is being written, which can then be used as the `write_offset` for
	// the next `Write()` call.
	//
	// If the resource does not exist (i.e., the resource has been deleted, or the
	// first `Write()` has not yet reached the service), this method returns the
	// error `NOT_FOUND`.
	//
	// The client **may** call `QueryWriteStatus()` at any time to determine how
	// much data has been processed for this resource. This is useful if the
	// client is buffering data and needs to know which data can be safely
	// evicted. For any sequence of `QueryWriteStatus()` calls for a given
	// resource name, the sequence of returned `committed_size` values will be
	// non-decreasing.
	QueryWriteStatus(ctx context.Context, in *QueryWriteStatusRequest, opts ...grpc.CallOption) (*QueryWriteStatusResponse, error)
	// `AdministerResource` is used to control the configuration of a resource, including
	// the access control policy of that resource. It is necessary to explicitly release
	// a resource on the desired APIs if authenticating using OAUTH2 tokens. This RPC is
	// not available to clients which authenticate using TLS certificate-based authentication.
	// Callers may later rescind access to uploaded resources by re-invoking this RPC and
	// altering the access policy contained within. If both access policies are set to DENY,
	// the release of the resource is fully rescinded.
	AdministerResource(ctx context.Context, in *ResourceAdminRequest, opts ...grpc.CallOption) (*ResourceAdminResponse, error)
	// `QueryResourceAdminSettings` is used to query the current access policies for the
	// resource in question. This RPC will fail with NOT_FOUND if invoked against an
	// invalid URI, or, if invoked against a uri where the final `write()` call has not
	// yet returned.
	QueryResourceAdminSettings(ctx context.Context, in *QueryResourceAdminRequest, opts ...grpc.CallOption) (*QueryResourceAdminResponse, error)
}

type byteStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewByteStreamClient(cc grpc.ClientConnInterface) ByteStreamClient {
	return &byteStreamClient{cc}
}

func (c *byteStreamClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (ByteStream_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ByteStream_serviceDesc.Streams[0], "/autonomic.ext.bytestream.ByteStream/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &byteStreamReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ByteStream_ReadClient interface {
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type byteStreamReadClient struct {
	grpc.ClientStream
}

func (x *byteStreamReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *byteStreamClient) Write(ctx context.Context, opts ...grpc.CallOption) (ByteStream_WriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ByteStream_serviceDesc.Streams[1], "/autonomic.ext.bytestream.ByteStream/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &byteStreamWriteClient{stream}
	return x, nil
}

type ByteStream_WriteClient interface {
	Send(*WriteRequest) error
	CloseAndRecv() (*WriteResponse, error)
	grpc.ClientStream
}

type byteStreamWriteClient struct {
	grpc.ClientStream
}

func (x *byteStreamWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *byteStreamWriteClient) CloseAndRecv() (*WriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *byteStreamClient) QueryWriteStatus(ctx context.Context, in *QueryWriteStatusRequest, opts ...grpc.CallOption) (*QueryWriteStatusResponse, error) {
	out := new(QueryWriteStatusResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.bytestream.ByteStream/QueryWriteStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *byteStreamClient) AdministerResource(ctx context.Context, in *ResourceAdminRequest, opts ...grpc.CallOption) (*ResourceAdminResponse, error) {
	out := new(ResourceAdminResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.bytestream.ByteStream/AdministerResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *byteStreamClient) QueryResourceAdminSettings(ctx context.Context, in *QueryResourceAdminRequest, opts ...grpc.CallOption) (*QueryResourceAdminResponse, error) {
	out := new(QueryResourceAdminResponse)
	err := c.cc.Invoke(ctx, "/autonomic.ext.bytestream.ByteStream/QueryResourceAdminSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ByteStreamServer is the server API for ByteStream service.
type ByteStreamServer interface {
	// `Read()` is used to retrieve the contents of a resource as a sequence
	// of bytes. The bytes are returned in a sequence of responses, and the
	// responses are delivered as the results of a server-side streaming RPC.
	Read(*ReadRequest, ByteStream_ReadServer) error
	// `Write()` is used to send the contents of a resource as a sequence of
	// bytes. The bytes are sent in a sequence of request protos of a client-side
	// streaming RPC.
	//
	// A `Write()` action is resumable. If there is an error or the connection is
	// broken during the `Write()`, the client should check the status of the
	// `Write()` by calling `QueryWriteStatus()` and continue writing from the
	// returned `committed_size`. This may be less than the amount of data the
	// client previously sent.
	//
	// Calling `Write()` on a resource name that was previously written and
	// finalized could cause an error, depending on whether the underlying service
	// allows over-writing of previously written resources.
	//
	// When the client closes the request channel, the service will respond with
	// a `WriteResponse`. The service will not view the resource as `complete`
	// until the client has sent a `WriteRequest` with `finish_write` set to
	// `true`. Sending any requests on a stream after sending a request with
	// `finish_write` set to `true` will cause an error. The client **should**
	// check the `WriteResponse` it receives to determine how much data the
	// service was able to commit and whether the service views the resource as
	// `complete` or not.
	Write(ByteStream_WriteServer) error
	// `QueryWriteStatus()` is used to find the `committed_size` for a resource
	// that is being written, which can then be used as the `write_offset` for
	// the next `Write()` call.
	//
	// If the resource does not exist (i.e., the resource has been deleted, or the
	// first `Write()` has not yet reached the service), this method returns the
	// error `NOT_FOUND`.
	//
	// The client **may** call `QueryWriteStatus()` at any time to determine how
	// much data has been processed for this resource. This is useful if the
	// client is buffering data and needs to know which data can be safely
	// evicted. For any sequence of `QueryWriteStatus()` calls for a given
	// resource name, the sequence of returned `committed_size` values will be
	// non-decreasing.
	QueryWriteStatus(context.Context, *QueryWriteStatusRequest) (*QueryWriteStatusResponse, error)
	// `AdministerResource` is used to control the configuration of a resource, including
	// the access control policy of that resource. It is necessary to explicitly release
	// a resource on the desired APIs if authenticating using OAUTH2 tokens. This RPC is
	// not available to clients which authenticate using TLS certificate-based authentication.
	// Callers may later rescind access to uploaded resources by re-invoking this RPC and
	// altering the access policy contained within. If both access policies are set to DENY,
	// the release of the resource is fully rescinded.
	AdministerResource(context.Context, *ResourceAdminRequest) (*ResourceAdminResponse, error)
	// `QueryResourceAdminSettings` is used to query the current access policies for the
	// resource in question. This RPC will fail with NOT_FOUND if invoked against an
	// invalid URI, or, if invoked against a uri where the final `write()` call has not
	// yet returned.
	QueryResourceAdminSettings(context.Context, *QueryResourceAdminRequest) (*QueryResourceAdminResponse, error)
}

// UnimplementedByteStreamServer can be embedded to have forward compatible implementations.
type UnimplementedByteStreamServer struct {
}

func (*UnimplementedByteStreamServer) Read(req *ReadRequest, srv ByteStream_ReadServer) error {
	return status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedByteStreamServer) Write(srv ByteStream_WriteServer) error {
	return status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedByteStreamServer) QueryWriteStatus(ctx context.Context, req *QueryWriteStatusRequest) (*QueryWriteStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWriteStatus not implemented")
}
func (*UnimplementedByteStreamServer) AdministerResource(ctx context.Context, req *ResourceAdminRequest) (*ResourceAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdministerResource not implemented")
}
func (*UnimplementedByteStreamServer) QueryResourceAdminSettings(ctx context.Context, req *QueryResourceAdminRequest) (*QueryResourceAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryResourceAdminSettings not implemented")
}

func RegisterByteStreamServer(s *grpc.Server, srv ByteStreamServer) {
	s.RegisterService(&_ByteStream_serviceDesc, srv)
}

func _ByteStream_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ByteStreamServer).Read(m, &byteStreamReadServer{stream})
}

type ByteStream_ReadServer interface {
	Send(*ReadResponse) error
	grpc.ServerStream
}

type byteStreamReadServer struct {
	grpc.ServerStream
}

func (x *byteStreamReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ByteStream_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ByteStreamServer).Write(&byteStreamWriteServer{stream})
}

type ByteStream_WriteServer interface {
	SendAndClose(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type byteStreamWriteServer struct {
	grpc.ServerStream
}

func (x *byteStreamWriteServer) SendAndClose(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *byteStreamWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ByteStream_QueryWriteStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWriteStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ByteStreamServer).QueryWriteStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.bytestream.ByteStream/QueryWriteStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ByteStreamServer).QueryWriteStatus(ctx, req.(*QueryWriteStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ByteStream_AdministerResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ByteStreamServer).AdministerResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.bytestream.ByteStream/AdministerResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ByteStreamServer).AdministerResource(ctx, req.(*ResourceAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ByteStream_QueryResourceAdminSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResourceAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ByteStreamServer).QueryResourceAdminSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autonomic.ext.bytestream.ByteStream/QueryResourceAdminSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ByteStreamServer).QueryResourceAdminSettings(ctx, req.(*QueryResourceAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ByteStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "autonomic.ext.bytestream.ByteStream",
	HandlerType: (*ByteStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryWriteStatus",
			Handler:    _ByteStream_QueryWriteStatus_Handler,
		},
		{
			MethodName: "AdministerResource",
			Handler:    _ByteStream_AdministerResource_Handler,
		},
		{
			MethodName: "QueryResourceAdminSettings",
			Handler:    _ByteStream_QueryResourceAdminSettings_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _ByteStream_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _ByteStream_Write_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "autonomic/ext/bytestream/bytestream.proto",
}
