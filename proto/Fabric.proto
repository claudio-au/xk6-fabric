/*-
 * ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 * Autonomic Proprietary 1.0
 * ——————————————————————————————————————————————————————————————————————————————
 * Copyright (C) 2019 Autonomic, LLC - All rights reserved
 * ——————————————————————————————————————————————————————————————————————————————
 * Proprietary and confidential.
 * 
 * NOTICE:  All information contained herein is, and remains the property of
 * Autonomic, LLC and its suppliers, if any.  The intellectual and technical
 * concepts contained herein are proprietary to Autonomic, LLC and its suppliers
 * and may be covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this information
 * or reproduction of this material is strictly forbidden unless prior written
 * permission is obtained from Autonomic, LLC.
 * 
 * Unauthorized copy of this file, via any medium is strictly prohibited.
 * ______________________________________________________________________________
 */

syntax = "proto3";

package com.autonomic.fabric;

option go_package = "github.com/autonomic-ai/fabric-common/src/main/proto/com/autonomic/fabric";
option java_package = "com.autonomic.fabric";
option java_outer_classname = "FabricProto";
option java_multiple_files = true;
option cc_enable_arenas = true;

import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";

// The fabric Envelope encompasses all telemetry and event data.
//
// The internal protobuf format is designed to be interacted with through the Fabric Library
// which provides and abstracted API for working with fabric envelopes and the many types of
// data they carry.
//
// The FabricEnvelopeProto and its child types are designed to allow for rapid routing, filtering
// and data selection without a full deserializaton of all data.   The Fabric API provides for
// on-demand deserialization and is not something the user has to do manually.
message FabricEnvelopeProto {
    // Id of the asset, this can be a vehicle_id, driver_id, etc...
    // aui:asset:vehicle:<uuid>
    string asset_id = 1;

    // Service which created the envelope
    string source = 2;

    // By default the envelope time will track the data_min_time (earliest time of all DataElements)
    // The Fabric API allows this to be overridden.
    google.protobuf.Timestamp envelope_time = 3;
    google.protobuf.Timestamp envelope_creation_time = 4;

    // NOTE:  The Fabric API automatically updates the min/max times based on dataelements contained
    //        within the envelope.
    // Earliest time of all DataElements in the data field.
    google.protobuf.Timestamp data_min_time = 5;
    // Latest time of all DataElements in the data field.
    google.protobuf.Timestamp data_max_time = 6;

    // Simple Tags: string name, string value, one value per name.
    map<string, string> tags = 7;

    // The primary payload of the envelope.  DataElements can contain different types of data such as
    // signal measurements and events.  An envelope can contain any number of elements and will often
    // have dozens or hundreds of entries.
    repeated DataElementProto data = 15;


    // Contains options driving the tracking and auditing behavior of this envelope and the data it
    // carries.
    TrackingOptionsProto tracking_options = 20;

    // Audit log containing audit entries for the envelope itself.
    AuditLogProto audit = 21;
    // Envelope tracing data
    TraceProto trace = 22;

    // Expanded Tags: string-or-integer name; single value of various types.
    map<int64, FabricEnvelopeTagDataProto> itags = 24;
    map<string, FabricEnvelopeTagDataProto> stags = 25;

    // The following two fields are used to generate key for vehicle
    // or device view materialization in a flow.
    //
    // All the DataElements of the FabricEnvelope are generated by the same
    // device, or internally generated. Hence all the DateElemenat have the
    // same device_asset_aui, either set to the same value or unset.
    // The following field is a copy of the DataElement's device_asset_aui field.
    string device_asset_aui = 26;

    // Vehicle AUI of the vehicle to which the DataElements are associated with.
    // If the DataElements are not associated with any vehicle
    // (device_asset_aui is unset) then this field is unset.
    string vehicle_asset_aui = 27;

    // Device info, set if device_asset_aui is set.
    AssetInfo asset_info = 28;
}

message FabricEnvelopeTagDataProto {
    oneof tag_value {
        bytes bytes_value = 1;
        string string_value = 2;
        bool bool_value = 3;
        int64 integer_value = 4;
        double double_value = 5;
    }
}

message AssetInfo {
    // VIN of the vehicle
    string vin = 1;
    // Device specific asset info
    string device_type = 2;
    string esn = 3;
    string iccid = 4;

    // content of the "business_unit" tag from Assets
    // used for envelope membership filtering.
    string business_unit = 5;

    // content of the "fuel_type" tag from Assets
    // used for envelope membership filtering.
    string fuel_type = 6;

    // device protocol - deprecated, reserved to prevent compatibility issues
    reserved 7; reserved "protocol";

    // device protocol version
    string protocol_version = 8;

    // device region code
    string region_code = 9;
}

// Data elements carry the payload of the envelope.
// The actual data is represent as an 'Any' which only deserializes when it is explicitly unpacked.
// This allows for efficient routing and filtering of signal measurements, events, etc via uri
// without deserializing all of the data. (which could be a nested structure or contain hundreds of
// elements)
//
// Initially element will carry Measurements (Held within a new version of Metric) and/or Events
//
// Context carries Measurements and Events related to this data element.   For example, the derived
// measurment 'aui:signal:au:speed_delta_over_limit' would be derived from speed_limit and speed.
// speed_limit and speed could optionally be stored as context so a down-stream processor could
// understand what data contributed to the calculation of the derived metric.
//
// Some payload element types, such as Event, also carry internal context, which could also be exposed
// through the same API.
message DataElementProto {
    string uri = 1;
    // Generation timestamp of Data Element defined by source (e.g processor, devices.)
    google.protobuf.Timestamp time_stamp = 2;
    // Timestamp capturing the arrival time of the DataElement into the TMC (if exists.)
    google.protobuf.Timestamp tmc_arrival_time_stamp = 7;

    google.protobuf.Any element = 3;
    repeated google.protobuf.Any context = 4;

    AuditLogProto audit = 5;

    ElementStats element_stats = 6;

    // cache of SAMPLE_RATE tag value for filtering
    string sample_rate = 8;

    // This is a temporary field for tracking the reconciled time stamp for state transitions
    // We need to track this to deal with an ordering issue in other services where
    // the event time cannot be relied upon.   The long term solution to this is to
    // emit resolved device connectivity states in a new proto.  At that time this
    // field will be deprecated.
    google.protobuf.Timestamp reconciled_time_stamp = 9;

    // Device asset AUI of the device that generated this data.
    // Syntax - aui:asset:device:<uuid>
    string device_asset_aui = 10;

    // AUI of the processors that "processed" this DataElement.
    // Syntax - aui:asset:processor:<uuid>
    //
    // Guideline for setting processor_aui and devcie_asset_aui by a processor
    // when processing one or more DataElements:
    // 1. If DataElement is not modified, then processor_aui is not set.
    //    The DataElement will be added as is to the existing FabricEnvelope.
    // 2. If DataElement is modified, then processor_aui is set,
    //    device_asset_aui is left unchanged.  Modifications include - new
    //    field added, existing field modified, update to tags.  The DataElement
    //    will be added to the existing FabricEnvelope.
    // 2. If a new DataElement is created, then following rules will apply:
    //    - device_asset_aui will be unset
    //    - processor_aui is set
    repeated string processor_aui = 11;

    // Command Type recorded here, when building data elements carrying
    // commands, to enable efficient filtering.
    string command_type = 12;
    reserved "ftcp_message_type"; reserved 13; // Keep these until they are removed.
    reserved "ftcp_message_name"; reserved 14; // Keep these until they are removed.
    string oem_message_name = 15;
    map<string, string> attribute_tags = 16;

}

// Statistics about the contents of a data element
//     well_known:  The number of well-known signals / events contained within
//         custom:  The number of custome signals / events
//                  custom is a signal/event that is not well known
//          other:  Count of all DataElements that are not well_known or custom signals/events
//      raw_bytes:  Total number of raw bytes carried in the DataElement.  This includes
//                  explicit raw data and opaque / additional data
message ElementStats {
    int32 well_known = 1;
    int32 custom = 2;
    int32 other = 3;
    int64 raw_bytes = 4;
    int64 additional_bytes=5;
}

message TrackingOptionsProto {
    bool auditEnabled = 1;
    bool tracingEnabled = 2;
}

message TraceProto {
    repeated google.protobuf.Any trace_data = 1;
}

message OpenTracingTraceProto {
    bytes trace_data = 1;
}

message AuditLogProto {
    repeated google.protobuf.Any audit_logs = 1;
}

message AuditLogEntryProto {
    enum Operation {
        // Do not use this default value.
        OPERATION_UNSPECIFIED = 0;

        REMOVED_CHILD = 1;
        FILTERED_CHILDREN = 2;
        CREATED = 3;
        MODIFIED = 4;

        AGGREGATED = 5;
        TAPPED = 6;
    }

    string actor = 1;
    Operation operation = 2;
    google.protobuf.Timestamp operation_time = 3;

    map<string, string> tags = 4;
    repeated string subject_uris = 5;
}
